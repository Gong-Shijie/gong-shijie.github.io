{"pages":[],"posts":[{"title":"1","text":"title: Mysql环境搭建tags: [mysql]categories: mysql windows下mysql的安装和使用 环境配置 https://dev.mysql.com/downloads/ 下载Mysql支持 +下载workBench GUI界面 参考进行安装Mysql 在my.ini中配置相关参数https://www.runoob.com/mysql/mysql-install.html 安装环境变量方便使用 注意使用cmd登录到mysql服务的时候尽量以管理员权限操作 workBench 基础操作 mysql -u root -p 连接mysql service CREATE DATABASE LOGDATABASE; 创建数据库更多使用https://www.runoob.com/mysql/mysql-tutorial.html 数据库事务","link":"/2020/04/25/1/"},{"title":"10","text":"title: 计算机网络：网络层tags: [计算机网络]categories: 计算机网络 网络层介绍 #1.网络层服务 转发：路由器查询转发表，指定数据输入输出的对应端口。路由：根据路由算法设计源到目的的路径。应用层提供的是两个应用的逻辑通信，网络层是两个主机之间的通信，传输分组。实现主机之间的通信有两种思路：有连接服务和无连接服务。有连接服务：首先就指定了路径，然后沿着该路径传输分组，比如虚电路网络。无连接服务：不指定路径，每个分组自己确定路径传输，比如数据报网络。出于减少转发表大小考虑，将地址改为一个地址范围（路由聚集）来匹配输出链路提高查表和路由效率。#2.协议 ##2.1 IPv4协议版本号：4-IPv4 6-IPv6服务类型：在网络提供分区服务的时候可以使用。一般不使用。生存时间：每经过一个路由器TTL减少1.协议：指示采用的是TCP或者是UDP 6为TCP 17为UDP片偏移：IP分组数据的相对偏移量标识：当IP数据报被分片后计数器加1，作为该片的标识符 标志位:作为标识是否允许分片以及片的位置信息。###2.1.1 分片每个分片可以保留的length字段就是MTU然后实际封装的数据为MTU-20offset：片偏移=实际封装的数据/8标识位MF最后一片为0（表示其为最后一片）其他为1###2.1.2 IP编址 子网掩码可以分离出IP地址中的网络地址和主机地址，那为什么要分离呢？因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机，否则就需要路由网关将数据包转发送到目的地提供了目的IP和子网掩码就可以确定目的主机所在的子网这样路由就可以到达主机所在的子网，进一步到达目的主机。而一个子网的主机的数量就为2的主机位数次方-2。之所以-2，因为图中的172.32.0.0用来路由器路由查找子网确定路径。172.32.1.255用来作为广播地址。##2.2 CIDR（无类路间路由）可以更加灵活的按需分配IP地址。也是一种描述子网的方法。##2.3 子网划分划分子网的目的：缩小广播域，和提高IP利用率。IP利用率：例如一个需要1万个IP地址的机构，若使用C类地址显然不能满足需要（使用C类地址的网络最多容纳256个主机）但使用B类地址则又造成了5.5万个IP地址的浪费！（使用B类地址的网络最多容纳6万5千个主机） IP地址的利用率将低于20%。广播率：一个组织机构有向所有子网下的主机发送数据的需求就使用广播，但是如果不划分为更加小的子网，那么广播的接收的主机数量就会特别大，为了降低无用发送而且精确广播我们划分了子网。就好比我们国家实行了各个省份的管理划分方法：通过向主机位部分借位成为新的网络地址的过程，也就是扩展网络地址的过程。 ##2.4 DHCP协议这样就实现了DHCP服务器可以动态的分配IP地址给客户机##2.5 NAT 网络地址转换采用NAT需要在路由器上面安装NAT软件，提供映射服务（这和我们的分层模型违背了）##2.5 ICMP通过路由器和目的主机返回ICMP报文封装在IP内返回源主机，进而实现对网络的监控和管理。##2.6 IPv6协议#3. 路由##3.1 路由算法###3.1.1 链路状态路由算法其中的D（v）为在N集合里面可达v和源直接到达v的最小值，也就是直接或者间接的最小值###3.1.2 距离向量算法 上述的选路环路问题可以通过毒性逆转的技术加以避免。它的基本思想是：如果Z的最短路径要通过邻居Y，那么它将告诉Y自己到目的节点的距离是∞。这样，Z向Y撒了一个善意的谎言，使得只要Z经过Y选路到X，它就会一直持续讲述这个谎言，这样Y也就永远不会尝试从Z选路到X了，也就避免了环路问题。我们将毒性逆转技术应用于上例。Y在更新自己的距离向量时，发现Z到X的距离是∞，于是它将d(x)无奈地更新为60，并向Z发送了更新报文。Z收到报文后更新自己的d(X)为50（直接选路到X），并发给Y更新报文（此时因为Z不需要经过Y进行选路，因此将告诉Y自己到X的距离为50）。Y在接收到Z的报文后，重新将距离更新为1 + 50 = 51，并告诉Z自己到X的距离是∞（实际是51）。Z收到报文后，发现最低耗费并没有改变，因此算法进入静止状态。###3.1.3 层次化路由##3.2 Internet层次化路由协议###3.2.1 AS内部协议IGP###3.2.2 AS间路由协议BGPAS内路由：内部最高效率（路由算法）到达内网每一主机AS间路由：通告外面的AS我这里或者经过我有哪些主机可达（选择性告诉基于服务商）","link":"/2020/04/25/10/"},{"title":"11","text":"title: 计算机网络：数据链路层tags: [计算机网络]categories: 计算机网络 数据链路层介绍 #1. 链路层服务数据链路层负责物理链路上相邻结点的数据传输。数据链路层根据上层网络层获取了到达目的主机的方法路径，然后通过实现结点之间的连接，那么就可以构成整个路径。数据链路层就是将一个个结点连接成为网络（使得上面的路径可以通路）。注意在计算机网络概念中：结点的概念是指主机和路由器。##1.1 差错检测注意这里因为是一种映射关系而不是完全拷贝一个副本来比对（浪费），映射关系可能在很多情况下依然成立但是自变量和因变量都发生了变化，这就意味着很多复杂的情况下差错检测不能保证100%正确。###1.1.1 奇偶校验码通过奇偶的个数来置校验位从而实现校验，奇校验1的个数为奇数，偶校验1的个数为偶数，如果不满足则通过校验位来补足。求CRC的R位如图所示首先根据G的位数-1作为0的个数在数据后面补0做除法所得的余数即是所需要的R.#2. MAC多路访问控制协议MAC协议就是用来解决共享线路资源问题诞生的协议，旨在研究多个方在共享线路时候遵循的策略##2.1 信道划分MAC协议 ###2.1.1 TDMA###2.1.2 FDMA##2.2 随机访问MAC协议 ###2.2.1 时隙ALOHA协议###2.2.2 CSMA协议##2.3 轮转访问MAC协议","link":"/2020/04/25/11/"},{"title":"14","text":"title: Android: Jetpack Databinding Navigation graph SaveStateViewModeltags: [android]categories: android 界面导航，页面状态管理 Save state ViewModel![](https://upload-images.jianshu.io/upload_images/19741117-363dd2ee02964842.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 为View Model增加了构造器，使得程序可以在后台被杀死的情况仍然保留状态数据 方法 ![](https://upload-images.jianshu.io/upload_images/19741117-b5bf7927e01f0020.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 通过ViewModel内的SaveStateHandle对象来保存和取出数据 进程被系统杀死时，会自动将SaveStateHandle中存值状态保存 123456789101112131415161718192021222324252627282930public class HomeViewModel extends ViewModel { SavedStateHandle savedStateHandle; public MutableLiveData&lt;String&gt; getHomeLiveData() { if(!savedStateHandle.contains(&quot;HOME_DATA&quot;)){ savedStateHandle.set(&quot;HOME_DATA&quot;,&quot;NULL&quot;); } return savedStateHandle.getLiveData(&quot;HOME_DATA&quot;); } public void setHomeLiveData() { this.savedStateHandle.set(&quot;HOME_DATA&quot;,&quot;JACK!&quot;); } public HomeViewModel(SavedStateHandle savedStateHandle) { this.savedStateHandle = savedStateHandle; }}``` *****#### DataBinding ![](https://upload-images.jianshu.io/upload_images/19741117-a94c27a25dce6e9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ![](https://upload-images.jianshu.io/upload_images/19741117-c5d45f9c7f7d7221.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![](https://upload-images.jianshu.io/upload_images/19741117-cc4e530801f8114a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![](https://upload-images.jianshu.io/upload_images/19741117-e284dddd268da446.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) android:text=&quot;@{String.valueOf(index + 1)}&quot; android:visibility=&quot;@{age &gt; 13 ? View.GONE : View.VISIBLE}&quot; android:transitionName=&apos;@{&quot;image_&quot; + id}&apos; 1 @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { // Inflate the layout for this fragment homeViewModel = new ViewModelProvider(requireActivity()).get(HomeViewModel.class); FragmentHomeBinding binding; binding = DataBindingUtil.inflate(inflater, R.layout.fragment_home, container, false); binding.setData(homeViewModel); binding.setLifecycleOwner(getActivity()); return binding.getRoot(); } 1这是在Fragment中使用的例子，如果在Activity中使用 ActivityMainBinding binding = ActivityMainBinding.inflate(getLayoutInflater()); 1用在ListView和RecyclerView中在Adapter中使用如下： ListItemBinding binding = ListItemBinding.inflate (layoutInflater, viewGroup, false); // or ListItemBinding binding = DataBindingUtil.inflate (layoutInflater, R.layout.list_item, viewGroup, false); @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { ItemSecondBinding binding = DataBindingUtil.getBinding(holder.itemView); binding.setUser(users.get(position)); binding.executePendingBindings(); } 12345678在recyclerView的Item中直接使用即可 #### Navigation graph ![](https://upload-images.jianshu.io/upload_images/19741117-7cb37251455eaa29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![](https://upload-images.jianshu.io/upload_images/19741117-3202fd28ca0e6b2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ![在入口Activity中添加](https://upload-images.jianshu.io/upload_images/19741117-adb71611ff646839.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)关键代码 @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); button = getView().findViewById(R.id.detailHomeBtn); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { //导航关键代码 NavController navController = Navigation.findNavController(v); navController.navigate(R.id.action_detailFragment_to_homeFragment); } }); } 123456MainActivity.java ``` setContentView(R.layout.activity_main); NavController navController = Navigation.findNavController(this,R.id.fragment); NavigationUI.setupActionBarWithNavController(this,navController); 搭配 1234567 //如果需要toolbar上的左上位置有icon back 就需要回调处理点击 @Override public boolean onSupportNavigateUp() { NavController navController = Navigation.findNavController(this,R.id.fragment); return navController.navigateUp(); }","link":"/2020/04/25/14/"},{"title":"13","text":"title: 小秘：个人时间管理工具tags: [demo]categories: demo 效率管理工具，MVVM 为用户提供方便使用的时间管理工具，在简洁的设计下提供以下功能： 待办事项管理 时间管理 便签管理 记录每日完成任务日志 github：https://github.com/Gong-Shijie/xiaoMi 应用截图 *** 个人觉得好用简洁，推荐给大家。","link":"/2020/04/25/13/"},{"title":"12","text":"title: Android：ROOM数据库框架tags: [android]categories: android Room数据库框架介绍 ROOMROOM对Sqlite进行了封装，直接使用ROOM来进行数据库访问。 代码：https://github.com/Gong-Shijie/RoomDemo ROOM数据库查询可以直接返回LiveData对象，每次CRUD都会自动更新该LiveData，LiveData始终是数据库最新值 利用该特性可以直接将数据库的变化，通过LiveData作为观察者传递到ViewModel，保证拿到的数据都是数据库中时刻最新的值 使用流程： Entry类–&gt;Dao–&gt;EntryRoomDatabase(单例模式)–&gt;Repository(从EntryRoomDatabase获得Dao)–&gt;在Repository中实现异步–&gt;AndroidViewModel通过Repository访问数据库CRUD 资料：https://codelabs.developers.google.com/codelabs/android-room-with-a-view/index.html?index=..%2F..index#0 数据库操作不应该在MainThread中，所以我们使用AsyncTask来进行数据库操作。UI层（Activity和Fragment）所有的数据应该都直接从ViewModel来获取，在ViewModel中我们使用AsyncTask来进行数据库操作。ROOM进行数据库操作依赖于Dao接口，在该接口中实现了很多数据库操作。 主要角色 Entry 实体类 Dao 定义接口数据库操作 继承RoomDatabase 通过ROOM实例化database返回Dao供调用 异步类调用Dao中数据库操作如AsyncTask Repository对操作进行封装 AndroidViewModel 聚合 Repository来执行数据库操作 使用方法Entry类–&gt;Dao–&gt;EntryRoomDatabase(单例模式)–&gt;Repository(从EntryRoomDatabase获得Dao)–&gt;在Repository中实现异步–&gt;AndroidViewModel通过Repository访问数据库CRUD 代码实现Entry 123456789101112131415161718192021222324252627282930313233@Entitypublic class Word { @PrimaryKey(autoGenerate = true) private int id; @ColumnInfo(name = &quot;english&quot;) private String english; @ColumnInfo(name = &quot;chinese&quot;) private String mean; public Word(String english, String mean) { this.english = english; this.mean = mean; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getEnglish() { return english; } public void setEnglish(String english) { this.english = english; } public String getMean() { return mean; } public void setMean(String mean) { this.mean = mean; }}``` Dao @Daopublic interface WordDao { @Insert void insertWord(Word… words); @Update void update(Word... words); @Delete void delete(Word... words); @Query(&quot;DELETE FROM WORD&quot;) void deleteAll(); @Query(&quot;SELECT * FROM WORD ORDER BY ID DESC&quot;) LiveData&lt;List&lt;Word&gt;&gt; getAll();} 1WordRoomDatabase @Database(entities = {Word.class},version = 1,exportSchema = false)public abstract class WordRoomDatabase extends RoomDatabase { public abstract WordDao getWordDao(); private static WordRoomDatabase INSTANCE; public static WordRoomDatabase getInstance(final Context context) { if (INSTANCE == null) { synchronized (WordRoomDatabase.class) { if (INSTANCE == null) { INSTANCE = Room.databaseBuilder(context.getApplicationContext(), WordRoomDatabase.class, “word_database”) .build(); } } } return INSTANCE; }} 1Repository public class Repository { private LiveData&lt;List&gt; wordsLive; public LiveData&lt;List&lt;Word&gt;&gt; getWordsLive() { return wordsLive; } //用来调用数据库操作 private WordDao wordDao; public Repository(Context context) { WordRoomDatabase wordRoomDatabase = WordRoomDatabase.getInstance(context.getApplicationContext()); wordDao = wordRoomDatabase.getWordDao(); wordsLive = wordDao.getAll(); } public void insert(Word… words){ new InsertTask(wordDao).execute(words); } public void delete(Word… words){ new DeleteTask(wordDao).execute(words); } public void update(Word… words){ new UpdateTask(wordDao).execute(words); } public void deleteAll(){ new DeleteAllTask(wordDao).execute(); }} VeiwModel public class MainViewModel extends AndroidViewModel { // ViewModel 没有很好的方法来获得一个Context 需要继承AndroidViewModel Repository repository; public MainViewModel(Application application) { super(application); this.repository = new Repository(application); } public LiveData&lt;List&gt; getAll(){ return repository.getWordsLive(); } public void insert(Word… words){ repository.insert(words); } public void update(Word… words){ repository.update(words); } public void delete(Word… words){ repository.delete(words); } public void deleteAll(){ repository.deleteAll(); }} *** ### 总结 ![总结](https://upload-images.jianshu.io/upload_images/19741117-df3a4dc1c88a8602.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","link":"/2020/04/25/12/"},{"title":"16","text":"title: Android:AlertDialogtags: [android]categories: android Dialog的简单使用 12345678AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); final AlertDialog dialog = builder.create(); //设置对话框布局View dialogView = View.inflate(MainActivity.this, R.layout.rename_layout, null); dialog.setView(dialogView); dialog.show(); //关闭对话框 dialog.dismiss()","link":"/2020/04/25/16/"},{"title":"18","text":"title: Android：androidx使用RecyclerView+CardViewtags: [android]categories: android recyclerView的使用方法 RecyclerView + CardViewgithub：https://github.com/Gong-Shijie/RecyclerView-CardView RecyclerView比ListView更加容易使用，而且实现的效果也更加丰富支持实现的效果：线性排列：分为横排列和竖排列；还支持瀑布流排列。 RecyclerView搭配CardView可以十分美观的满足你的各种需求。 添加RecyclerView依赖 implementation ‘androidx.recyclerview:recyclerview:1.0.0’ 添加CardView依赖 implementation ‘androidx.cardview:cardview:1.0.0’ RecyclerView 以上三种布局方式都是基于layoutmanager来实现的。 实现步骤 在mainActivity中初始化用来显示的数据集合List 1234567private void iniflist() { Data data = new Data(); int length = data.imageList.size(); for (int i = 0; i &lt; length; i++) { flist.add(new Fruit(data.imageList.get(i), data.nameList.get(i))); } } 书写RecyclerView对应的XML文件 1234567 &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_height=&quot;match_parent&quot; android:layout_width=&quot;match_parent&quot; /&gt;``` * 定义每一item的布局结合CardView可以将布局放在卡片内 &lt;ImageView android:id=&quot;@+id/fruit_image&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;left&quot; /&gt; &lt;TextView android:id=&quot;@+id/fruit_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_toRightOf=&quot;@id/fruit_image&quot; android:layout_marginTop=&quot;10dp&quot; /&gt; 123* 定义全局的RecyclerView并且findviewbyid * 在mainActivity中为recyclerView定义layoutManager和adapter iniflist(); recyclerView = findViewById(R.id.recycler_view); // 通过LayoutManager来呈现出列表或者横向滑动列表或者是瀑布流的效果 // 横向或者竖向的列表布局 LinearLayoutManager layoutManager = new LinearLayoutManager(this,0,false); // 瀑布流布局 StaggeredGridLayoutManager layoutManager1=new StaggeredGridLayoutManager(3,1); // 网格布局 GridLayoutManager layoutManager2 = new GridLayoutManager(this,2); recyclerView.setLayoutManager(layoutManager); FruitAdapter adapter = new FruitAdapter(flist); recyclerView.setAdapter(adapter); 1234567* 完成Adapter类的创建，并且在内部定义static类ViewHolder 继承抽象类RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt;实现方法: ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType)创建viewHolder完成监听注册 onBindViewHolder(@NonNull ViewHolder holder, int position)将数据取出填充到布局 getItemCount()返回数据项数 内部类static class ViewHolder extends RecyclerView.ViewHolder class FruitAdapter extends RecyclerView.Adapter { private List flist; public FruitAdapter(List flist) { this.flist = flist; } @NonNull @Override public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { //完成创建ViewHolder和将布局用布局加载器加载到viewHolder中 //为viewHolder里面的子view注册监听事件 View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item,parent,false); final ViewHolder viewHolder = new ViewHolder(view); viewHolder.fView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { //viewHolder.getAdapterPosition()将会返回被点击的item的index int position = viewHolder.getAdapterPosition(); Fruit fruit = flist.get(position); Toast.makeText(v.getContext(),\"Click:\"+fruit.getF_name(),Toast.LENGTH_SHORT).show(); } }); viewHolder.imageView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { int position = viewHolder.getAdapterPosition(); Fruit fruit = flist.get(position); Toast.makeText(v.getContext(),\"Click: Image\",Toast.LENGTH_SHORT).show(); } }); return viewHolder; } @Override public void onBindViewHolder(@NonNull ViewHolder holder, int position) { //根据position将每一个flist里面的值绑定到viewholderFruit fruit = flist.get(position);holder.imageView.setImageResource(fruit.getF_image());holder.textView.setText(fruit.getF_name()); } @Override public int getItemCount() { //返回flist的长度 return flist.size(); } static class ViewHolder extends RecyclerView.ViewHolder{ //这些控件都可以设置监听事件View fView;ImageView imageView;TextView textView; public ViewHolder(@NonNull View itemView) { super(itemView); fView = itemView.findViewById(R.id.f_view); imageView = itemView.findViewById(R.id.fruit_image); textView = itemView.findViewById(R.id.fruit_name); } } } 12345***### CardView 设置卡片为圆角效果 设置阴影有立体感 设置点击呈现涟漪效果 &lt;androidx.cardview.widget.CardView android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/f_view&quot; android:layout_width=&quot;wrap_content&quot; app:cardElevation=&quot;100dp&quot; app:cardCornerRadius=&quot;4dp&quot; android:clickable=&quot;true&quot; android:foreground=&quot;?android:attr/selectableItemBackground&quot; &gt; &lt;TextView android:id=&quot;@+id/fruit_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_toRightOf=&quot;@id/fruit_image&quot; android:layout_marginTop=&quot;10dp&quot; /&gt; &lt;/androidx.cardview.widget.CardView&gt; 123***### 关键代码 **Data.java(预加载初始化打包数据)** public class Data { public List imageList = new ArrayList&lt;&gt;(); public List nameList = new ArrayList&lt;&gt;(); public Data() { imageList.add(R.drawable.apple_pic); imageList.add(R.drawable.banana_pic); imageList.add(R.drawable.cherry_pic); imageList.add(R.drawable.grape_pic); imageList.add(R.drawable.mango_pic); imageList.add(R.drawable.orange_pic); imageList.add(R.drawable.pear_pic); imageList.add(R.drawable.pineapple_pic); imageList.add(R.drawable.strawberry_pic); imageList.add(R.drawable.watermelon_pic); nameList.add(&quot;Apple&quot;); nameList.add(&quot;Banana&quot;); nameList.add(&quot;Cherry&quot;); nameList.add(&quot;Grape&quot;); nameList.add(&quot;Mango&quot;); nameList.add(&quot;Orange&quot;); nameList.add(&quot;Pear&quot;); nameList.add(&quot;Pineapple&quot;); nameList.add(&quot;Strawberry&quot;); nameList.add(&quot;Watermelon&quot;); imageList.add(R.drawable.apple_pic); imageList.add(R.drawable.banana_pic); imageList.add(R.drawable.cherry_pic); imageList.add(R.drawable.grape_pic); imageList.add(R.drawable.mango_pic); imageList.add(R.drawable.orange_pic); imageList.add(R.drawable.pear_pic); imageList.add(R.drawable.pineapple_pic); imageList.add(R.drawable.strawberry_pic); imageList.add(R.drawable.watermelon_pic); nameList.add(&quot;Apple&quot;); nameList.add(&quot;Banana&quot;); nameList.add(&quot;Cherry&quot;); nameList.add(&quot;Grape&quot;); nameList.add(&quot;Mango&quot;); nameList.add(&quot;Orange&quot;); nameList.add(&quot;Pear&quot;); nameList.add(&quot;Pineapple&quot;); nameList.add(&quot;Strawberry&quot;); nameList.add(&quot;Watermelon&quot;); }} 1**FruitAdapter.java** class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; { private List flist; public FruitAdapter(List&lt;Fruit&gt; flist) { this.flist = flist; } @NonNull @Override public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {//完成创建ViewHolder和将布局用布局加载器加载到viewHolder中//为viewHolder里面的子view注册监听事件 View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item,parent,false); final ViewHolder viewHolder = new ViewHolder(view); viewHolder.fView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { //viewHolder.getAdapterPosition()将会返回被点击的item的index int position = viewHolder.getAdapterPosition(); Fruit fruit = flist.get(position); Toast.makeText(v.getContext(),”Click:”+fruit.getF_name(),Toast.LENGTH_SHORT).show(); } }); viewHolder.imageView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { int position = viewHolder.getAdapterPosition(); Fruit fruit = flist.get(position); Toast.makeText(v.getContext(),”Click: Image”,Toast.LENGTH_SHORT).show(); } }); return viewHolder; } @Override public void onBindViewHolder(@NonNull ViewHolder holder, int position) { //根据position将每一个flist里面的值绑定到viewholderFruit fruit = flist.get(position);holder.imageView.setImageResource(fruit.getF_image());holder.textView.setText(fruit.getF_name()); } @Override public int getItemCount() { //返回flist的长度 return flist.size(); } static class ViewHolder extends RecyclerView.ViewHolder{ //这些控件都可以设置监听事件View fView;ImageView imageView;TextView textView; public ViewHolder(@NonNull View itemView) { super(itemView); fView = itemView.findViewById(R.id.f_view); imageView = itemView.findViewById(R.id.fruit_image); textView = itemView.findViewById(R.id.fruit_name); } }} 1**Main** public class MainActivity extends AppCompatActivity { //凡是需要使用的进行操作的数据(对象类型)不要忘记初始化否则会造成空引用 private List&lt;Fruit&gt; flist = new ArrayList&lt;&gt;(); private RecyclerView recyclerView; @SuppressLint(&quot;WrongConstant&quot;) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); iniflist(); recyclerView = findViewById(R.id.recycler_view);// 通过LayoutManager来呈现出列表或者横向滑动列表或者是瀑布流的效果// 横向或者竖向的列表布局 LinearLayoutManager layoutManager = new LinearLayoutManager(this,0,false);// 瀑布流布局 StaggeredGridLayoutManager layoutManager1=new StaggeredGridLayoutManager(3,1);// 网格布局 GridLayoutManager layoutManager2 = new GridLayoutManager(this,2); recyclerView.setLayoutManager(layoutManager); FruitAdapter adapter = new FruitAdapter(flist); recyclerView.setAdapter(adapter); } private void iniflist() { Data data = new Data(); int length = data.imageList.size(); for (int i = 0; i &lt; length; i++) { flist.add(new Fruit(data.imageList.get(i), data.nameList.get(i))); } }} ```参考文献：《第一行代码》","link":"/2020/04/25/18/"},{"title":"15","text":"title: Android：Jetpack Navigation DrawerMenu框架 界面间导航抽屉菜单tags: [android]categories: android 应用框架，抽屉菜单和底部导航 demo:https://github.com/Gong-Shijie/navWithDrawer 应用框架Google建议开发者只使用一个Activity搭配Fragment来架构程序可以直接new一个Navigation Drawer的项目 进一步调整为需要的效果 Drawer菜单首先要了解菜单Menu，菜单在Android部件系统中有三种类型对于这些菜单我们都可以通过他们来进行页面导航切换使用方法是直接在创建项目的时候使用提供的模板 根据这些默认模板可以减少项目构建的封锁步骤viewmodel也可以勾选省去创建ViewModel步骤 创建一个Navigation Drawer 应用 重写方法实现对所有菜单监听 1234567891011121314//只要是菜单选项被点击都会调用该方法 @Override public boolean onOptionsItemSelected(@NonNull MenuItem item) { switch (item.getItemId()) { case R.id.action_settings: Toast.makeText(this, &quot;Click !&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.action_settidfngs: Toast.makeText(this, &quot;Click ! &quot;, Toast.LENGTH_SHORT).show(); break; } return super.onOptionsItemSelected(item); } 动态修改和设置抽屉菜单 1234567891011121314151617 //动态添加menuItem项设置id Menu menu = navigationView.getMenu(); menu.clear(); menu.add(0, R.id.nav_gallery, 0, &quot;gallery&quot;).setIcon(R.drawable.ic_menu_gallery); menu.add(0, R.id.nav_send, 1, &quot;send&quot;).setIcon(R.drawable.ic_menu_send);//设置点击监听但是不要消耗点击事件否则影响导航 menu.getItem(0).setOnMenuItemClickListener();``` *****#### Navigation ![](https://upload-images.jianshu.io/upload_images/19741117-79c6c96892eab3b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)*****#### 主要代码 MainActivity.java public class MainActivity extends AppCompatActivity { private AppBarConfiguration mAppBarConfiguration; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = findViewById(R.id.toolbar); //实现toolbar替换默认的Actionbar setSupportActionBar(toolbar); DrawerLayout drawer = findViewById(R.id.drawer_layout); NavigationView navigationView = findViewById(R.id.nav_view);//将NavController 和app bar这种menu绑定从而实现Fragment切换的管理// 也可以和其他的menu类型绑定 NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment); mAppBarConfiguration = new AppBarConfiguration.Builder( navController.getGraph() ) .setDrawerLayout(drawer) .build(); NavigationUI.setupActionBarWithNavController(this, navController, mAppBarConfiguration); //使得drawer显示 NavigationUI.setupWithNavController(navigationView, navController); //动态添加menuItem项设置id Menu menu = navigationView.getMenu(); menu.clear(); menu.add(0, R.id.nav_gallery, 0, &quot;gallery&quot;).setIcon(R.drawable.ic_menu_gallery); menu.add(0, R.id.nav_send, 1, &quot;send&quot;).setIcon(R.drawable.ic_menu_send); } //设置actionbar中的菜单显示 @Override public boolean onCreateOptionsMenu(Menu menu) { // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true; } //只要是菜单选项被点击都会调用该方法 @Override public boolean onOptionsItemSelected(@NonNull MenuItem item) { switch (item.getItemId()) { case R.id.action_settings: Toast.makeText(this, &quot;Click !&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.action_settidfngs: Toast.makeText(this, &quot;Click ! &quot;, Toast.LENGTH_SHORT).show(); break; } return super.onOptionsItemSelected(item); } //处理左上角的菜单被点击的时候的回调 @Override public boolean onSupportNavigateUp() { NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment); return NavigationUI.navigateUp(navController, mAppBarConfiguration) || super.onSupportNavigateUp(); }} 123***** activity_main.xml &lt;androidx.drawerlayout.widget.DrawerLayout xmlns:android=”http://schemas.android.com/apk/res/android&quot; xmlns:app=”http://schemas.android.com/apk/res-auto&quot; xmlns:tools=”http://schemas.android.com/tools&quot; android:id=”@+id/drawer_layout” android:layout_width=”match_parent” android:layout_height=”match_parent” android:fitsSystemWindows=”true” tools:openDrawer=”start”&gt; &lt;include layout=&quot;@layout/app_bar_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;com.google.android.material.navigation.NavigationView android:id=&quot;@+id/nav_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; android:fitsSystemWindows=&quot;true&quot; app:headerLayout=&quot;@layout/nav_header_main&quot; app:menu=&quot;@menu/activity_main_drawer&quot; /&gt;&lt;/androidx.drawerlayout.widget.DrawerLayout&gt; 12***** HomeFragment.java public class HomeFragment extends Fragment { private HomeViewModel homeViewModel; public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { homeViewModel = new ViewModelProvider(requireActivity()).get(HomeViewModel.class); View root = inflater.inflate(R.layout.fragment_home, container, false); final TextView textView = root.findViewById(R.id.text_home); homeViewModel.getText().observe(getViewLifecycleOwner(), new Observer&lt;String&gt;() { @Override public void onChanged(@Nullable String s) { textView.setText(s); } }); return root; }}","link":"/2020/04/25/15/"},{"title":"17","text":"title: Android:MVVM架构:LiveData MutableLiveDatatags: [android]categories: android mvvm架构理解 MVVMgithub : https://github.com/Gong-Shijie/demo_MVVM MVVM是一种高效组织代码的架构。和MVP架构一样，架构的目的在于： 关注点分离 降低耦合 增加代码的质量其中MVVM有一个巨大的优点就是单元测试起来极为方便，在组织大型而且复杂的工程的时候MVVM可以发挥巨大的作用。 LiveData一个巨大的特点是观察者模式，通过LiveData的这一特点，在ViewModel中的LiveData数据就可以通过观察者模式一旦数据发生了变化就可以对UI做出更新处理。可以灵活利用LiveData在repository中进而数据更新通知modleView来进行逻辑处理，对数据进行处理产出UI需要的数据，这个数据也设定为LiveData那么View层就可以对UI需要的数据进行响应更新。 这里主要研究通过LiveData来实现的MVVM架构方式。 原理这里我们需要有层次的思想来理解MVVM就好比计算机网络，我们将整个计算机网络服务划分为自顶而下的应用层、传输层、网络层、数据链路层、物理层各自在自己的模块接受下层的服务向上层提供自己应该提供的服务。理解MVVM架构的方式，我们需要理解每一个模块接受什么，提供什么服务，这样才可以灵活运用和架构MVVM View层：UI响应式更新View只负责处理UI事务，通过观察ViewModel中的数据变化来更新UI Model层：数据组织、存储来源Model层提供数据，获取数据库、文件、或者远端服务器的数据。提供给ViewModel来进行逻辑处理。也就是应用数据的源头。通常增加Repository层通过Repository层来连接数据库和服务器返回数据给Model，Model，再将数据提供给上层。 ViewModle层：数据处理产出UI关心的数据 结构 一个Mvvmdemo实战效果 用户通过悬浮按钮来进行交互（View层）；添加item到数据库然后从数据库取数据（Model层）；对取出的数据进行处理（ViewModel层）；更新到界面（View层）； 代码MainActivityViewModel.java 12345678910111213141516171819202122232425262728293031public class MainActivityViewModel extends ViewModel { //记住新建对象创建实例，否则容易出现空引用问题 private DbFruit dbFruit = DbFruit.getInstance(); private List&lt;Fruit&gt; fruitList=new ArrayList&lt;&gt;(); private MutableLiveData&lt;List&lt;Fruit&gt;&gt; mutableLiveData= new MutableLiveData&lt;&gt;(); public MutableLiveData&lt;List&lt;Fruit&gt;&gt; getMutableLiveData() { return mutableLiveData; } public void additem(){ //dbFruit用来操作数据库 dbFruit.additem(); fruitList = dbFruit.getallFruit(); //调用postValue来更新数据，该更新就被观察者观察到做相应的处理 mutableLiveData.postValue(fruitList); } public void inidata(){ //创建数据库 LitePal.getDatabase(); fruitList =null; fruitList = dbFruit.getallFruit(); //mutableLiveData的第一次赋值使用setValue mutableLiveData.setValue(fruitList); }}``` *** MainActivity.java public class MainActivity extends AppCompatActivity { private FloatingActionButton floatingActionButton; private RecyclerView recyclerView; private FruitAdapter fruitAdapter; private MainActivityViewModel mainActivityViewModel; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); recyclerView = findViewById(R.id.recycler_view); floatingActionButton = findViewById(R.id.add_btn); //创建ViewModel mainActivityViewModel = ViewModelProviders.of(this).get(MainActivityViewModel.class); //初始化数据 mainActivityViewModel.inidata(); //初始化显示数据到界面 iniRecyclerView(); //观察到数据变化就更新adapter需要的数据从而更新界面 mainActivityViewModel.getMutableLiveData().observe(this, new Observer&lt;List&lt;Fruit&gt;&gt;() { @Override public void onChanged(List&lt;Fruit&gt; fruits) { //更新adapter updataUIdata(); } }); //交互添加item按钮执行添加操作 floatingActionButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { //添加item到数据库，更新mutableLiveData mainActivityViewModel.additem(); } }); } public void iniRecyclerView(){ LinearLayoutManager linearLayoutManager = new LinearLayoutManager(this,RecyclerView.VERTICAL,false); recyclerView.setLayoutManager(linearLayoutManager); fruitAdapter= new FruitAdapter(mainActivityViewModel.getMutableLiveData().getValue()); recyclerView.setAdapter(fruitAdapter); } public void updataUIdata(){ fruitAdapter.setFlist(mainActivityViewModel.getMutableLiveData().getValue()); recyclerView.setAdapter(fruitAdapter); }} 12*** DbFruit.java(数据仓库提供数据服务) //单例模式public class DbFruit { private static DbFruit dbFruit = new DbFruit(); private DbFruit() { new Fruit(R.drawable.apple_pic,”apple”).save(); new Fruit(R.drawable.banana_pic,”apple”).save(); new Fruit(R.drawable.cherry_pic,”apple”).save(); new Fruit(R.drawable.grape_pic,”apple”).save(); new Fruit(R.drawable.mango_pic,”apple”).save(); new Fruit(R.drawable.orange_pic,”apple”).save(); new Fruit(R.drawable.pear_pic,”apple”).save(); new Fruit(R.drawable.pineapple_pic,”apple”).save(); new Fruit(R.drawable.strawberry_pic,”apple”).save(); new Fruit(R.drawable.watermelon_pic,”apple”).save(); } public static DbFruit getInstance(){ return dbFruit; } public List&lt;Fruit&gt; getallFruit(){ return DataSupport.findAll(Fruit.class); } public void additem() { Fruit fruit = new Fruit(); fruit.setF_image(R.drawable.apple_pic); fruit.setF_name(&quot;add dpple!&quot;); fruit.save(); }} *** XML（悬浮按钮使用）&lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id=”@+id/add_btn” android:layout_width=”60dp” android:layout_height=”60dp” android:layout_alignParentBottom=”true” android:layout_alignParentRight=”true” android:layout_margin=”16dp” android:src=”@drawable/ic_add” /&gt;","link":"/2020/04/25/17/"},{"title":"19","text":"title: Android：LitePal数据库、沉浸式布局、可视化数据库tags: [android]categories: android 数据库框架Litepal的使用（建议学Room框架） LitePalDemo数据库的完整解决方案github地址https://github.com/Gong-Shijie/LitePalDemo.git 添加依赖 implementation ‘org.litepal.android:core:1.4.1’ 添加assets目录并创建XML文件project视图下app/src/main目录→New→Directory 修改配置文件 创建javabean映射为数据表 每一个属性相当于表里的一列数据库升级时可以增加javabean或者修改增删除对应的属性将version属性值加1即可 数据的增加删除查询修改都对应对于DataSupport内方法的调用调用方法返回结果是一个javabean对象的List效果： 可视化数据库工具添加依赖 debugImplementation ‘com.amitshekhar.android:debug-db:1.0.0’ 配置手机的adb环境方法如下：https://jingyan.baidu.com/article/17bd8e52f514d985ab2bb800.html输入adb forward tcp:8080 tcp:8080如果你的端口8080被占用则使用其他端口比如修改为8088端口（位于app的gradle文件） 123456789101112131415buildTypes {release {minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'),'proguard-rules.pro' }debug {//这里 resValue(&quot;string&quot;,&quot;PORT_NUMBER&quot;,&quot;8088&quot;)}}} 保证手机和电脑出于相同wifi下run项目然后浏览器输入localhost：8080就可以看到你的数据库和表 沉浸式界面布局在stylt.xml下修改-&gt;创建一个notitle的主题后面我们会在配置文件使用它 12345678910111213141516171819&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;NoTitle&quot; parent=&quot;Theme.AppCompat.DayNight.NoActionBar&quot;&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 当前主题使用到的颜色 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;color name=&quot;colorPrimary&quot;&gt;#FFFFFF&lt;/color&gt; &lt;color name=&quot;colorPrimaryDark&quot;&gt;#999999&lt;/color&gt;&lt;!-- edittext下划线和光标颜色--&gt; &lt;color name=&quot;colorAccent&quot;&gt;#999999&lt;/color&gt;&lt;/resources&gt; 可以修改为自己所需要的颜色最后一步修改配置文件这样app将根据配置的style notitle的style就不显示状态栏沉浸式布局的解决方案 数据库增删查改代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class MainActivity extends AppCompatActivity implements View.OnClickListener { private Button btn_add; private Button btn_dele; private Button btn_que; private Button btn_upd; private EditText edit_id; private EditText edit_name; private EditText edit_age; private EditText edit_info; private TextView textView; private String data = &quot;&quot;;/* 使用该库默认的主键是id且自增长 如果需要可以增加一个xx_id字段*/ public void showdb(List&lt;User&gt; users) { data = &quot;&quot;; for (User ele : users) { data = data + ele.getId() + &quot; &quot; + ele.getName() + &quot; &quot; + ele.getAge() + &quot; &quot; + ele.getInfo() + &quot; &quot; + ele.getUpclass() + &quot;\\n&quot;; } Log.i(&quot;edit&quot;, data); textView.setText(data); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); LitePal.getDatabase(); Log.i(&quot;MainActivity&quot;, &quot;创建数据库！&quot;); btn_add = findViewById(R.id.btn_add); btn_dele = findViewById(R.id.btn_dele); btn_que = findViewById(R.id.btn_que); btn_upd = findViewById(R.id.btn_update); edit_id = findViewById(R.id.id_edit); edit_name = findViewById(R.id.name_edit); edit_age = findViewById(R.id.age_edit); edit_info = findViewById(R.id.info_edit); textView = findViewById(R.id.text_data); btn_add.setOnClickListener(this); btn_dele.setOnClickListener(this); btn_que.setOnClickListener(this); btn_upd.setOnClickListener(this); List&lt;User&gt; users = DataSupport.findAll(User.class); showdb(users); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.btn_add: User user = new User(); Log.i(&quot;edit_id&quot;, edit_id.getText().toString()); user.setId(Integer.parseInt(edit_id.getText().toString())); user.setName(edit_name.getText().toString()); user.setAge(Integer.parseInt(edit_age.getText().toString())); user.setInfo(edit_info.getText().toString()); user.save(); List&lt;User&gt; afteradd = DataSupport.findAll(User.class); showdb(afteradd); break; case R.id.btn_dele: DataSupport.deleteAll(User.class, &quot;id = ?&quot;, edit_id.getText().toString()); List&lt;User&gt; afterdele = DataSupport.findAll(User.class); showdb(afterdele); break; case R.id.btn_que:List&lt;Song&gt; songs = LitePal.where(&quot;name like ? and duration &lt; ?&quot;, &quot;song%&quot;, &quot;200&quot;).order(&quot;duration&quot;).find(Song.class); List&lt;User&gt; quedata = DataSupport.where(&quot;id=?&quot;, edit_id.getText().toString()).find(User.class); showdb(quedata);/* 类似于sql语句的函数可以连缀组合调用 List&lt;User&gt; usersques = DataSupport.select(&quot;id&quot;,&quot;name&quot;) .where(&quot;id=?&quot;,edit_id.getText().toString()) .order(&quot;age&quot;) .limit(10) .find(User.class);*/ break; case R.id.btn_update: User upduser = new User(); upduser.setName(edit_name.getText().toString()); upduser.setAge(Integer.parseInt(edit_age.getText().toString())); upduser.setInfo(edit_info.getText().toString());//也可以直接update对应id即可 upduser.updateAll(&quot;id=?&quot;, edit_id.getText().toString()); List&lt;User&gt; afterupd = DataSupport.findAll(User.class); showdb(afterupd); break; } }} XML布局：同类的控件都放在一个父布局内比如本文的四个edittext和四个button放在父布局内所有在竖直方向上面的位置摆放都通过在父布局内配置margin来实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;androidx.percentlayout.widget.PercentRelativeLayout xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;&lt;androidx.percentlayout.widget.PercentRelativeLayout android:layout_width=&quot;match_parent&quot; app:layout_marginTopPercent=&quot;5%&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;EditText android:id=&quot;@+id/id_edit&quot; android:layout_width=&quot;wrap_content&quot; app:layout_widthPercent=&quot;25%&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;id&quot; android:textSize=&quot;30sp&quot; &gt;&lt;/EditText&gt; &lt;EditText android:id=&quot;@+id/name_edit&quot; app:layout_widthPercent=&quot;25%&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignTop=&quot;@id/id_edit&quot; android:layout_toRightOf=&quot;@id/id_edit&quot; android:hint=&quot;name&quot; android:textSize=&quot;30sp&quot;&gt;&lt;/EditText&gt; &lt;EditText android:id=&quot;@+id/age_edit&quot; android:layout_width=&quot;wrap_content&quot; app:layout_widthPercent=&quot;25%&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignTop=&quot;@id/id_edit&quot; android:layout_toRightOf=&quot;@id/name_edit&quot; android:hint=&quot;age&quot; android:textSize=&quot;30sp&quot;&gt;&lt;/EditText&gt; &lt;EditText app:layout_widthPercent=&quot;25%&quot; android:id=&quot;@+id/info_edit&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignTop=&quot;@id/id_edit&quot; android:layout_toRightOf=&quot;@id/age_edit&quot; android:hint=&quot;info&quot; android:textSize=&quot;30sp&quot;&gt;&lt;/EditText&gt;&lt;/androidx.percentlayout.widget.PercentRelativeLayout&gt; &lt;androidx.percentlayout.widget.PercentRelativeLayout xmlns:tools=&quot;http://schemas.android.com/tools&quot; app:layout_marginTopPercent=&quot;13%&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/btn_add&quot; android:layout_width=&quot;wrap_content&quot; app:layout_widthPercent=&quot;25%&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;增加&quot; android:textSize=&quot;25sp&quot; &gt;&lt;/Button&gt; &lt;Button android:id=&quot;@+id/btn_dele&quot; android:layout_toRightOf=&quot;@id/btn_add&quot; android:layout_width=&quot;wrap_content&quot; app:layout_widthPercent=&quot;25%&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;删除&quot; android:textSize=&quot;25sp&quot; &gt;&lt;/Button&gt; &lt;Button android:id=&quot;@+id/btn_que&quot; android:layout_toRightOf=&quot;@id/btn_dele&quot; android:layout_width=&quot;wrap_content&quot; app:layout_widthPercent=&quot;25%&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;查找&quot; android:textSize=&quot;25sp&quot; &gt;&lt;/Button&gt; &lt;Button android:id=&quot;@+id/btn_update&quot; android:layout_toRightOf=&quot;@id/btn_que&quot; android:layout_width=&quot;wrap_content&quot; app:layout_widthPercent=&quot;25%&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;修改&quot; android:textSize=&quot;25sp&quot; &gt;&lt;/Button&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:background=&quot;@color/colorPrimary&quot; android:layout_below=&quot;@id/btn_que&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_marginTop=&quot;10dp&quot; android:layout_marginLeft=&quot;15dp&quot; android:id=&quot;@+id/text_data&quot; android:inputType=&quot;textMultiLine&quot; android:textSize=&quot;30sp&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;&lt;/TextView&gt; &lt;/RelativeLayout&gt; &lt;/androidx.percentlayout.widget.PercentRelativeLayout&gt; &lt;/androidx.percentlayout.widget.PercentRelativeLayout&gt;&lt;/RelativeLayout&gt;&lt;!--尽量减少独立的控件都将相似的控件放在一个布局内--&gt;&lt;!--控件摆放的竖直方向位置尽量在父布局内设置--&gt;","link":"/2020/04/25/19/"},{"title":"2","text":"title: Binder：IPC进程通信探秘tags: [android]categories: android 理解Binder机制和IPC进程通信 进程和线程是开发中极其重要的模块。除了使用进程、线程来独立完成任务，我们也需要对他们通信的机制进行学习。 操作系统层次看进程进程的通信方式： 管道消息队列共享内存信号量Socket 操作系统操作系统有内核空间、用户进程空间。所有的用户层的进程都是在用户态，操作系统是位于内核态。 内核态权限高，对于一些接口设备进行管理，用户态也可以通过系统调用（获取权限提升）来访问内核提供的服务。 进程在操作系统中角色内核对进程进行管理和调度执行。 资源分配操作系统内核将一些资源分配给进程，进程又将任务拆分交给线程，不同进程和操作系统空间的关系可以对照不同线程和进程的关系。需要我们解决 同步 异步 以及进行通信。 管道通过在内核空间开辟一块共享的缓冲区来进行数据的写入和读取一切皆是文件是Linux哲学。也可以理解管道为一个特殊的文件，通过管道我们可以实现将A进程写入的数据在B进程读取。理解为特殊的文件，有点类似于复制粘贴的过程。在Linux中我们获取到文件描述符后就可以打开对应的文件。 消息队列类似于管道，消息队列是一段发送数据块，另外的进程来接受数据块来进行通信。进行通信时候需要不断IO操作，在不同进程中进行拷贝粘贴。这是很浪费资源的。也是很耗时的。 共享内存比起消息队列，共享内存的方式，是不同的进程映射到同一块内核中的内存，称之为共享内存。但是共享内存不会对共享的资源进行访问控制。于是我们有了信号量。 信号量和线程中的信号量是一个意思，解决的都是对于临界资源的访问控制问题，通过有限的信号量来进行访问控制。信号量是通过PV操作来控制，P操作就是信号量的请求，V操作是对信号量的释放。 进入正题… Binder(android中的特色进程通信机制)原理Binder在操作系统层面是通过共享内存的方式来进行通信的。具体来说是通过内存映射理解Binder：操作系统将内存资源分配给独立的进程，每个进程之间的内存空间是独立的不可以相互访问，内核空间可以对进程进行不对称的访问。Binder中进程都拿出一块内存来交给内核作为共享的内存，然后将这部分共享的内存来连接到进程。这样不同进程间连接到同一块内存。映射同一块内存后就可以对内存进行一致性的访问，将需要共享的内容对象（Binder对象）放在映射的内存空间中。常用场景：需要传输的Binder对象在B进程返回，在A端的serviceConnected中获取B的Binder实例，就可以在A端进行调用和通信。Android中很多的机制都是通过Binder来进行的。一些Framework层次的服务向client请求进行响应通信都是基于Binder。因为内核和用户应用就是跨进程的。 可传输的Binder对象放在映射的共享内存中，服务端提供客户端使用。 Activity等组件的启动就是在Binder机制和Handler机制的综合运用。 ActivityThread通过ApplicationThread和AMS进行进程间通讯，AMS以进程间通信的方式完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程中去执行，这个过程就是。主线程的消息循环模型","link":"/2020/04/25/2/"},{"title":"21","text":"title: Android：界面设计自定义预览屏幕tags: [android]categories: android 自定义屏幕调试布局 #####当我们设计xml界面时候，需要根据不同的手机屏幕来查看目前的设计是否合理，或者说以指定的屏幕开始你的设计，下面实现自定义一个手机屏幕来预览你的xml设计如果找不到你想要的，我们可以通过下方的方法添加最后点击finish就完成了为了确保更新可以重启你的Android studio现在就可以在这个屏幕大小的基础上来写xml界面了，如果需要适配各种屏幕也可以自定义其他屏幕的尺寸查看设计效果。","link":"/2020/04/25/21/"},{"title":"20","text":"title: Android：百分比布局 布局嵌套 Log Toasttags: [android]categories: android 布局适配之屏幕适配方案：百分比布局 #####添加依赖 implementation ‘androidx.percentlayout:percentlayout:1.0.0’ github： https://github.com/Gong-Shijie/PercentLayoutDemo.git 可使用的布局：PercentFrameLayout、PercentRelativeLayout除了使用FrameLayout 和 RealitiveLayout 自带的属性之外可以使用的####百分比布局扩展属性：layout_widthPercentlayout_heightPercentlayout_marginPercentlayout_marginLeftPercentlayout_marginTopPercentlayout_marginRightPercentlayout_marginBottomPercentlayout_marginStartPercentlayout_marginEndPercent####RealitiveLayout常用属性：android:layout_centerHrizontal 水平居中android:layout_centerVertical 垂直居中android:layout_centerInparent 相对于父元素完全居中android:layout_alignParentBottom 贴紧父元素的下边缘android:layout_alignParentLeft 贴紧父元素的左边缘android:layout_alignParentRight 贴紧父元素的右边缘android:layout_alignParentTop 贴紧父元素的上边缘 android:layout_below 在某元素的下方android:layout_above 在某元素的上方android:layout_toLeftOf 在某元素的左边Android:layout_toRightOf 在某元素的右边android:layout_alignTop 本元素的上边缘和某元素的上边缘对齐android:layout_alignLeft 本元素的左边缘和某元素的左边缘对齐android:layout_alignBottom 本元素的下边缘和某元素下边缘对齐android:layout_alignRight 本元素的右边缘和某元素右边缘对齐 android:layout_marginBottom 离某元素底边缘的距离Android:layout_marginLeft 离某元素左边缘的的距离Android:layout_marginRight 离某元素的右边缘的距离Android:layout_marginTop 离某元素上边缘的距离android:hint 设置EditText为空时输入的提示信息android:gravity 对该view内容的限定：靠上 下 左 右android:layout_gravity=”right” 用来设置该Container（组件）的靠左 靠右 margin 空白 align 对齐 gravity 重心摆放####Log使用使用log Android studio 内使用log filter设置tag 来查看对应的logLog.v()：打印一些最为繁琐、意义不大的日志信息Log.d()：打印一些调试信息(logd+tab)Log.i()：打印一些比较重要的数据，可帮助你分析用户行为数据（logi+tab）Log.w()：打印一些警告信息，提示程序该处可能存在的风险(logw+tab)Log.e()：打印程序中的错误信息(loge+tab) ####Toast自定义高度和显示内容 1234Toast toast = Toast.makeText(getApplicationContext(),null,Toast.LENGTH_SHORT); toast.setGravity(Gravity.TOP|Gravity.CENTER, 0,1580); toast.setText(\"登录失败！\"); toast.show(); ####代码：xml实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.LoginActivity&quot;&gt; &lt;androidx.percentlayout.widget.PercentFrameLayout xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/text_login&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center|top&quot; android:text=&quot;登陆&quot; android:textAlignment=&quot;center&quot; android:textSize=&quot;30sp&quot; app:layout_marginTopPercent=&quot;8%&quot; /&gt; &lt;androidx.percentlayout.widget.PercentRelativeLayout android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:background=&quot;#1222&quot; app:layout_heightPercent=&quot;50%&quot; app:layout_marginLeftPercent=&quot;12.5%&quot; app:layout_marginTopPercent=&quot;25%&quot; app:layout_widthPercent=&quot;75%&quot; &gt; &lt;EditText app:layout_marginTopPercent =&quot;30%&quot; app:layout_marginLeftPercent =&quot;10%&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;account :&quot; android:textSize=&quot;30sp&quot;&gt;&lt;/EditText&gt; &lt;EditText app:layout_marginTopPercent =&quot;50%&quot; app:layout_marginLeftPercent =&quot;10%&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;password :&quot; android:textSize=&quot;30sp&quot;&gt;&lt;/EditText&gt; &lt;Button android:text=&quot;登陆&quot; android:layout_centerHorizontal=&quot;true&quot; android:textSize=&quot;30sp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:layout_marginTopPercent =&quot;75%&quot; &gt;&lt;/Button&gt; &lt;/androidx.percentlayout.widget.PercentRelativeLayout&gt; &lt;/androidx.percentlayout.widget.PercentFrameLayout&gt;&lt;/RelativeLayout&gt; java代码： package com.example.myapplication; import androidx.appcompat.app.AppCompatActivity; import android.content.Intent; import android.os.Bundle; import android.util.Log; import android.view.Gravity; import android.view.View; import android.widget.Button; import android.widget.Toast; public class MainActivity extends AppCompatActivity implements View.OnClickListener{ private Button btn_1; private Button btn_2; private Button btn_3; private Button btn_4; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btn_1 = findViewById(R.id.btn_1); btn_1.setOnClickListener(this); btn_2 = findViewById(R.id.btn_2); btn_2.setOnClickListener(this); btn_3 = findViewById(R.id.btn_3); btn_3.setOnClickListener(this); btn_4 = findViewById(R.id.btn_4); btn_4.setOnClickListener(this); } @Override public void onClick(View v) { switch(v.getId()){ case R.id.btn_1: Intent intent = new Intent(MainActivity.this,LoginActivity.class); startActivity(intent); break; case R.id.btn_2: Toast.makeText(this,\"click btn2!\",Toast.LENGTH_SHORT).show(); break; case R.id.btn_3: Log.i(\"MainActivity:\",\"click btn3!\"); break; /*使用log Android studio 内使用log filter设置tag 来查看对应的log Log.v()：打印一些最为繁琐、意义不大的日志信息 Log.d()：打印一些调试信息(logd+tab) Log.i()：打印一些比较重要的数据，可帮助你分析用户行为数据（logi+tab） Log.w()：打印一些警告信息，提示程序该处可能存在的风险(logw+tab) Log.e()：打印程序中的错误信息(loge+tab) */ case R.id.btn_4: Toast toast = Toast.makeText(getApplicationContext(),null,Toast.LENGTH_SHORT); toast.setGravity(Gravity.TOP|Gravity.CENTER, 0,1580); toast.setText(\"登录失败！\"); toast.show(); break; } } }","link":"/2020/04/25/20/"},{"title":"22","text":"title: Android：权限申请、运行时权限、调用相册选择图片tags: [android]categories: android 权限申请 调用相册过程就涉及了对于危险权限读取存储的申请、隐式跳转到相册一个极简的demo方便回顾这两个点：github：https://github.com/Gong-Shijie/pickphotos.git 权限由于Android对于应用需要的权限做了分类处理分为了危险权限和普通权限，对于普通权限的申请可以直接在AndroidManifest里面申请即可但是对于一些涉及用户隐私和财产的权限被列为危险权限，如果需要使用这些危险权限，就必须在程序使用的时候进行授权，运行时权限申请。 危险权限 因此对于开发时候需要什么样的权限，如果是普通权限直接申请，如果是危险权限则走流程进行运行时权限。判断是否授权和请求授权 1234//判断是否授权这里以一个权限为例if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {//没有授权进行权限申请 ActivityCompat.requestPermissions(MainActivity.this, new String[]{ Manifest.permission. WRITE_EXTERNAL_STORAGE }, 1); 用户授权结束活动后回调 123456789101112public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) { switch (requestCode) { case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { openAlbum(); } else { Toast.makeText(this, &quot;You denied the permission&quot;, Toast.LENGTH_SHORT).show(); } break; default: } } 隐式意图跳转 12345private void openAlbum() { Intent intent = new Intent(&quot;android.intent.action.GET_CONTENT&quot;); intent.setType(&quot;image/*&quot;); startActivityForResult(intent, CHOOSE_PHOTO); // 打开相册 } 活动结束后的回调得到图片的Uri 1234567891011@Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { super.onActivityResult(requestCode, resultCode, data); switch (requestCode){ case CHOOSE_PHOTO: if(resultCode == RESULT_OK){ //使用Glide来加载图片data.getData()得到图片的Uri Glide.with(this).load(data.getData()).into(photo); } } } 隐式启动intent隐式启动intent来跳转到相应的活动，根据action和category同时匹配要跳转的意图这两个属性可以在AndroidManife.xml里面配置每个活动用来响应的action和category一个Activity只有一个action但是可以有多个category但是需要考虑intent并不智能比如启动相册：需要采用隐式启动 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Intent intent = new Intent(&quot;android.intent.action.GET_CONTENT&quot;); intent.setType(&quot;image/*&quot;); startActivityForResult(intent, CHOOSE_PHOTO); // 打开相册``` 意图指定action为获取相应的内容， 但是不知道要获取什么内容，只有通过setType指定为image这样这个意图才可以成功跳转到相册。 这里由于是采用了startActivityForResult函数启动意图，在跳转到相册执行了操作后，得到的数据就在onActivityResult里面处理返回的数据。 ***#### 常见的action：ACTION_MAIN 作为一个主要的进入口，而并不期望去接受数据ACTION_VIEW 向用户去显示数据ACTION_ATTACH_DATA 用于指定一些数据应该附属于一些其他的地方，例如，图片数据应该附属于联系人ACTION_EDIT 访问已给的数据，提供明确的可编辑ACTION_PICK 从数据中选择一个子项目，并返回你所选中的项目ACTION_CHOOSER 显示一个activity选择器，允许用户在进程之前选择他们想要的ACTION_GET_CONTENT 允许用户选择特殊种类的数据，并返回（特殊种类的数据：照一张相片或录一段音）ACTION_DIAL 拨打一个指定的号码，显示一个带有号码的用户界面，允许用户去启动呼叫ACTION_CALL 根据指定的数据执行一次呼叫（ACTION_CALL在应用中启动一次呼叫有缺陷，多数应用ACTION_DIAL，ACTION_CALL不能用在紧急呼叫上，紧急呼叫可以用ACTION_DIAL来实现） ACTION_SEND 传递数据，被传送的数据没有指定，接收的action请求用户发数据ACTION_SENDTO 发送一跳信息到指定的某人ACTION_ANSWER 处理一个打进电话呼叫ACTION_INSERT 插入一条空项目到已给的容器ACTION_DELETE 从容器中删除已给的数据ACTION_RUN 运行数据，无论怎么ACTION_SYNC 同步执行一个数据ACTION_PICK_ACTIVITY 为已知的Intent选择一个Activity，返回别选中的类ACTION_SEARCH 执行一次搜索ACTION_WEB_SEARCH 执行一次web搜索***#### category：CATEGORY_APP_BROWSER 和ACTION_MAIN一起使用，用来启动浏览器应用程序CATEGORY_APP_CALCULATOR 和ACTION_MAIN一起使用，用来启动计算器应用程序CATEGORY_APP_CALENDAR 和ACTION_MAIN一起使用，用来启动日历应用程序CATEGORY_APP_CONTACTS 和ACTION_MAIN一起使用，用来启动联系人应用程序CATEGORY_APP_EMAIL 和ACTION_MAIN一起使用，用来启动邮件应用程序CATEGORY_APP_GALLERY 和ACTION_MAIN一起使用，用来启动图库应用程序CATEGORY_APP_MAPS 和ACTION_MAIN一起使用，用来启动地图应用程序CATEGORY_APP_MARKET 这个activity允许用户浏览和下载新的应用程序CATEGORY_APP_MESSAGING ACTION_MAIN一起使用，用来启动短信应用程序CATEGORY_APP_MUSIC 和ACTION_MAIN一起使用，用来启动音乐应用程序CATEGORY_BROWSABLE 能够被浏览器安全调用的activity必须支持这个 ***#### 主要代码以打开相册选择图片为例子：##### 权限组问题 虽然有权限组的存在但是申请一个组内的权限应该遵循将需要的权限都列出的习惯。ActivityCompat.requestPermissions(MainActivity.this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE,Manifest.permission.READ_EXTERNAL_STORAGE}, GET_STORAGE_PERMISSION);} 12345678##### 通过返回的Uri显示图片 因为Android KitKat后对于Uri做了封装所以对于回调中的数据Uri的取出得到图片路径的逻辑有些复杂，我们不重复制造轮子取出图片的path用bitmap加载图片 ###### 使用Glide框架来加载图片 ###### 添加依赖&gt; implementation 'com.github.bumptech.glide:glide:4.10.0' annotationProcessor 'com.github.bumptech.glide:compiler:4.10.0'简单加载图片方法： //使用Glide来加载图片data.getData()得到图片的Uri Glide.with(this).load(data.getData()).into(photo); 1##### MainActivity代码： public class MainActivity extends AppCompatActivity { private static final int CHOOSE_PHOTO = 1; private static final int GET_STORAGE_PERMISSION = 2; private Button pick; private ImageView photo; private String imagepath = &quot;&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); pick = findViewById(R.id.pick_btn); photo = findViewById(R.id.photo); pick.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) { //没有授权进行权限申请 ActivityCompat.requestPermissions(MainActivity.this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE,Manifest.permission.READ_EXTERNAL_STORAGE}, GET_STORAGE_PERMISSION);} else{ pickPhoto(); } } }); } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) { case GET_STORAGE_PERMISSION: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { pickPhoto(); } else { Toast.makeText(this, &quot;You denied the permission&quot;, Toast.LENGTH_SHORT).show(); } break; } } @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { super.onActivityResult(requestCode, resultCode, data); switch (requestCode){ case CHOOSE_PHOTO: if(resultCode == RESULT_OK){ //使用Glide来加载图片data.getData()得到图片的Uri Glide.with(this).load(data.getData()).into(photo); } } } private void pickPhoto() { Intent intent = new Intent(Intent.ACTION_GET_CONTENT); intent.setType(&quot;image/*&quot;); startActivityForResult(intent, CHOOSE_PHOTO); // 打开相册 }} ``` 总结：申请权限调用对应的应用核心流程在于对于几个回调函数的处理 参考：书籍：&lt;&lt;第一行代码&gt;&gt;","link":"/2020/04/25/22/"},{"title":"23","text":"title: Android：OkHttp请求网络数据、JSON、GSON解析数据tags: [android]categories: android okhttp框架和 GSON解析数据 github地址：https://github.com/Gong-Shijie/network.git OkHttp请求服务器数据添加权限 123&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt;&lt;/uses-permission&gt; ``` 添加OkHttp、GSON依赖 implementation ‘com.squareup.okhttp3:okhttp:3.4.1’implementation ‘com.google.code.gson:gson:2.7’ 123456789101112##### URI和URL、URNuri Uniform Resource Identifier url uniform resource locator urn Uniform Resource Name ![三者关系](https://upload-images.jianshu.io/upload_images/19741117-8c292577c5fed81d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 理解uri关键在于id，url在于locator位置、urn在于name你可以通过在地球上确定一个人的方法来理解他们 uri相当于你的id card number 可以唯一标识你 urn相当于你的名字我们认为也是可以唯一标识你 url相当于你的地理位置精确到你比如某某省某某市某街道多少号你的位置也可以唯一标识你 ##### okhttp使用方法：**get方法** OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(“https://v1.hitokoto.cn/&quot;) .build(); Response response = client.newCall(request).execute(); String jsondata = response.body().string(); 123456789101112131415**post方法** 通过在get方法的基础上增加一个requestBody 然后增加连缀.post(requestBody)即可 post可以使用把填写的表单的信息放在报文的body中进行传输 get直接把用户填写的数据增加到uri里面用户也可以看到 **安全性**这样的get暴露毕竟是不安全的 但是post也并不是安全的 因为即使在bodu里面的数据，只要我们截取了数据包，还是可以提取body里面的数据 解决安全问题不能简单通过get和post来解决 于是诞生了https就是增加SSL、TLS来封装http 利用公钥和私钥的技术来解决数据的加密传输的问题 公钥私钥就是服务器和客户端使用客户端发给服务器的私钥来加密和封装数据 即使其他用户截取了数据包不知道私钥也无法解析数据 RequestBody requestBody = new FormBody.Builder() .add(“username”,”admin”) .add(“password”,”admin”) .build(); OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(“https://v1.hitokoto.cn/&quot;) .post(requestBody) .build(); Response response = client.newCall(request).execute(); String jsondata = response.body().string(); 12345678服务器返回的是json格式的数据 ![json数据格式](https://upload-images.jianshu.io/upload_images/19741117-b9be8bdd3587b780.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)这样我们就获得了这样的json数据的字符串 我们需要对这些字符串做处理 可以使用json或者是GSON工具来处理 GSON使用特别方便，只需要创建javabean然后就可以获取***#### GSON解析数据 // 若服务器返回的是当个json我们可以使用JSONObject（传入数据）来构造一个json对象取值 JSONObject jsonObject = new JSONObject(jsondata);// 如果是多个json数据就使用JSONArray来获取 JSONArray jsonArray = new JSONArray(jsondata); Gson gson = new Gson();// 如果是多条json数据，使用List来构造返回一个List对象的javaBean List oneList = gson.fromJson(jsondata,new TypeToken&lt;List&gt;(){}.getType()); for(One one:oneList){ one.getHitokoto(); } One one = gson.fromJson(jsondata, One.class); 1234567对于少数的json数据你可以使用json来解析，但是对于大多数情况，使用GSON更加快捷和方便 创建GSON对象，通过调用gson对象的fromJson（）方法 **参数：json格式的字符串数据 + 需要返回的对象的类型** 这样就可以返回一个List和一个对象来自于你创建的javabean 通过调用这个javabean的方法你可以获取每个key对应的value ***#### 主要代码： public class MainActivity extends AppCompatActivity { private TextView textview; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textview = findViewById(R.id.showdata); textview.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { getdata(); } }); } private void getdata() { new Thread(new Runnable() { @Override public void run() { try { OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(&quot;https://v1.hitokoto.cn/&quot;) .build(); Response response = client.newCall(request).execute(); String jsondata = response.body().string(); String words = &quot;&quot;;// 由于服务器返回的是当个json我们可以使用JSONObject（传入数据）来构造一个json对象取值// JSONObject jsonObject = new JSONObject(jsondata);// 如果是多个json数据就使用JSONArray来获取// JSONArray jsonArray = new JSONArray(jsondata); Gson gson = new Gson();// 如果是多条json数据，使用List来构造返回一个List对象的javaBean// List oneList = gson.fromJson(jsondata,new TypeToken&lt;List&gt;(){}.getType());// for(One one:oneList){// one.getHitokoto();// } One one = gson.fromJson(jsondata, One.class); words = one.getHitokoto(); changeUI(words); } catch (IOException e) { e.printStackTrace(); } } }).start(); } private void changeUI(final String data) { new Thread(new Runnable() { @Override public void run() { textview.setText(data); } }).start(); }}```","link":"/2020/04/25/23/"},{"title":"25","text":"title: Android：探究后台：服务 BindService Bindertags: [android]categories: android service后台 gitHub:https://github.com/Gong-Shijie/ServiceDemo 服务Service服务有两种启动方式： startService（）方式开始的服务 bindService（）方式开启的服务 LivaData(Demo中使用到)依赖：123implementation &quot;android.arch.lifecycle:extensions:1.1.1&quot;implementation &quot;android.arch.lifecycle:viewmodel:1.1.1&quot;implementation &quot;android.arch.lifecycle:livedata:1.1.1&quot; 启动和特性服务仍然是运行在主线程，两种服务有着不同的生命周期，也可以搭配一起使用。两种方法都可以实现数据从活动到服务，通过在intent添加数据，可以在服务内从intent内取出数据。 12345//在Intent内添加数据就可以在服务内从Intent取出 startService(serviceIntent); bindService(serviceIntent,serviceConnection,BIND_AUTO_CREATE);``` 在服务内获取来自intent的数据 //Bind方式启动服务时候调用，返回IBinder类型的接口供活动调用 @Override public IBinder onBind(Intent intent) { // intent即可取出携带数据 Log.i(&quot;gong&quot;,&quot;sevice bind&quot;); return randomNumBinder; } //start方式开始服务时候会调用，如果处理耗时任务需要new线程 //startID每一次开启一个服务，都会有不同的startID //在开启服务时候可以在intent填写数据实现交互 @Override public int onStartCommand(Intent intent, int flags, final int startId) { new Thread(new Runnable() { @Override public void run() { Log.i(&quot;gong&quot;,&quot;startID: &quot;+startId); startRandomNumberGenerator(); } }).start(); return START_STICKY; }12345678910111213141516171819*** ## start方式启动的服务 该方式的特点是和活动之间没有很强的交互性，可以利用LiveData增加数据交互性。 该种方式会调用onStartConmmand（），在该方法内我们实现需要进行的后台服务操作逻辑。 该函数的返回值的类型有三种，适用于不同类型的需求。 ![官方文档中的介绍](https://upload-images.jianshu.io/upload_images/19741117-37cb3be555afc2ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 如果在服务中开启了线程，注意在服务Desdroy后，线程不会自动终止，需要自己实现**在服务销毁后终止线程**。线程会在执行run后终止。 *** ## bind方式启动的服务 该方式通过Binder机制，可以实现活动和服务的交互，这种交互很强，包括了**数据上的交互和对服务行为上的控制**。完全可以通过Binder获得Service实例从而控制调用Service内的方法。 ![bindService的几种类型和实现](https://upload-images.jianshu.io/upload_images/19741117-28a6aa0637b5499a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) * Local binding指在应用进程内进行bind * Remote binding指跨进程实现的bind 注意跨进程通信即（IPC）涉及的重要概念： * IBinder接口是用来交互的桥梁 * Messenger继承自Binder也是实现IPC的一种方法 * AIDL也是用于实现IPC ![local binding](https://upload-images.jianshu.io/upload_images/19741117-4303b21bcd218b7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ![remote binding](https://upload-images.jianshu.io/upload_images/19741117-ba685e3ff0d2e9cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) //Bind方式启动服务时候调用，返回IBinder类型的接口供活动调用 @Override public IBinder onBind(Intent intent) { Log.i(&quot;gong&quot;,&quot;sevice bind&quot;); return randomNumBinder; } //构造返回的接口传递Service实例 class RandomNumBinder extends Binder{ MyService getService(){ return MyService.this; } }12绑定端代码 serviceConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { randomNumBinder = (MyService.RandomNumBinder) service; myService = randomNumBinder.getService(); } @Override public void onServiceDisconnected(ComponentName name) { } }; bindService(serviceIntent,serviceConnection,BIND_AUTO_CREATE);123456789101112131415*** ## 服务service生命周期 ![生命周期](https://upload-images.jianshu.io/upload_images/19741117-371b8459655cc326.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) *** ## 总结 ##### 需求选择启动方式 根据具体需要来启动Service，建立service后，可以理解为客户端和服务端。 * 如果只是需要进行数据上的交互，建议start方式+ LiveData 即可保证service内的数据通过Livedata可以在活动中获取。 * 如果还需要对服务进行行为控制，强交互，比如控制服务内的函数的调用，那么就需要我使用bindService方式启动服务，还可以搭配start方式后bind根据具体需求。 ##### 生命周期的问题：* 结束服务：其他组件调用stopService（）或者 服务内自行调用stopself（） * bind的service只有unbind后才可以调用stopservice来结束 * 可以开启多个服务，调用一次stopService即可结束所有服务 * bind也可以直接开启服务当所有bind的组件unbind后service就会销毁 * 如果需要启动多个service可以使用官方文档推荐的方法使用Handler机制来处理 public class HelloService extends Service { private Looper mServiceLooper; private ServiceHandler mServiceHandler; // Handler that receives messages from the thread private final class ServiceHandler extends Handler { public ServiceHandler(Looper looper) { super(looper); } @Override public void handleMessage(Message msg) { // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. long endTime = System.currentTimeMillis() + 5*1000; while (System.currentTimeMillis() &lt; endTime) { synchronized (this) { try { wait(endTime - System.currentTimeMillis()); } catch (Exception e) { } } } // Stop the service using the startId, so that we don’t stop // the service in the middle of handling another job stopSelf(msg.arg1); } } @Override public void onCreate() { // Start up the thread running the service. Note that we create a // separate thread because the service normally runs in the process’s // main thread, which we don’t want to block. We also make it // background priority so CPU-intensive work will not disrupt our UI. HandlerThread thread = new HandlerThread(“ServiceStartArguments”, Process.THREAD_PRIORITY_BACKGROUND); thread.start(); // Get the HandlerThread&apos;s Looper and use it for our Handler mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); } @Override public int onStartCommand(Intent intent, int flags, int startId) { Toast.makeText(this, “service starting”, Toast.LENGTH_SHORT).show(); // For each start request, send a message to start a job and deliver the // start ID so we know which request we&apos;re stopping when we finish the job Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; mServiceHandler.sendMessage(msg); // If we get killed, after returning from here, restart return START_STICKY; } @Override public IBinder onBind(Intent intent) { // We don’t provide binding, so return null return null; } @Override public void onDestroy() { Toast.makeText(this, “service done”, Toast.LENGTH_SHORT).show(); }} 1234使用Handler机制细思极妙，官方文档需要经常查看。 *** ## MyServiceDemo代码 MyService.java public class MyService extends Service { private static final int MAX = 100; private static final int MIN = 0; private MutableLiveData&lt;String&gt; mutableLiveData = new MutableLiveData&lt;&gt;(); private String logStr = new String(); private int mRandomNumber=0; private Boolean mIsRandomGeneratorOn = true; private IBinder randomNumBinder = new RandomNumBinder(); //Bind方式启动服务时候调用，返回IBinder类型的接口供活动调用 @Override public IBinder onBind(Intent intent) { Log.i(&quot;gong&quot;,&quot;sevice bind&quot;); return randomNumBinder; } //构造返回的接口传递Service实例 class RandomNumBinder extends Binder{ MyService getService(){ return MyService.this; } } @Override public boolean onUnbind(Intent intent) { Log.i(&quot;gong&quot;,&quot;sevice unbind!&quot;); return super.onUnbind(intent); } //start方式开始服务时候会调用，如果处理耗时任务需要new线程 //startID每一次开启一个服务，都会有不同的startID //在开启服务时候可以在intent填写数据实现交互 @Override public int onStartCommand(Intent intent, int flags, final int startId) { new Thread(new Runnable() { @Override public void run() { Log.i(&quot;gong&quot;,&quot;startID: &quot;+startId); startRandomNumberGenerator(); } }).start(); return START_STICKY; } private void startRandomNumberGenerator(){ while (mIsRandomGeneratorOn){ try{ Thread.sleep(1000); if(mIsRandomGeneratorOn){ mRandomNumber =new Random().nextInt(MAX)+MIN; logStr = logStr + mRandomNumber+&quot; &quot;; mutableLiveData.postValue(logStr); Log.i(&quot;gong&quot;,&quot;&quot;+mRandomNumber); } }catch (InterruptedException e){ } } } @Override public void onCreate() { super.onCreate(); Log.i(&quot;gong&quot;,&quot;Service create!&quot;); logStr = &quot;&quot;; mIsRandomGeneratorOn = true; } //销毁服务的时候记住关闭线程，线程在执行run内方法后终止 @Override public void onDestroy() { super.onDestroy(); Log.i(&quot;gong&quot;,&quot;Service destroy!&quot;); mIsRandomGeneratorOn = false; } public int getmRandomNumber() { return mRandomNumber; } //提供livadata来更新数据到活动界面 public MutableLiveData&lt;String&gt; getMutableLiveData() { return mutableLiveData; }} 1MainActivity.java public class MainActivity extends AppCompatActivity implements View.OnClickListener { private TextView textView ; private TextView showLog ; private Button startService ; private Button bindService ; private Button unBindService ; private Button stopService ; private Button getnumber; Intent serviceIntent ; private MyService.RandomNumBinder randomNumBinder; private MyService myService; ServiceConnection serviceConnection; Boolean isBindService =false; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); iniview(); serviceIntent = new Intent(this,MyService.class); } @Override public void onClick(View v) { switch(v.getId()){ case R.id.startService: startService(serviceIntent); break; case R.id.bindService: bindmService(); break; case R.id.unBindService: unbindmService(); break; case R.id.stopService: stopService(serviceIntent); break; case R.id.getnumber: setObserver(); setmText(myService.getmRandomNumber()); break; } } private void setmText(int getmRandomNumber) { textView.setText(getmRandomNumber+&quot;&quot;); } public void iniview(){ textView = findViewById(R.id.textView); showLog = findViewById(R.id.showLog); startService = findViewById(R.id.startService); bindService = findViewById(R.id.bindService); unBindService = findViewById(R.id.unBindService); stopService = findViewById(R.id.stopService); getnumber = findViewById(R.id.getnumber); startService.setOnClickListener(this); bindService.setOnClickListener(this); unBindService.setOnClickListener(this); stopService.setOnClickListener(this); getnumber.setOnClickListener(this); } //bind service获取调动服务的接口myService可以来和Service交互 public void bindmService(){ serviceConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { randomNumBinder = (MyService.RandomNumBinder) service; myService = randomNumBinder.getService(); } @Override public void onServiceDisconnected(ComponentName name) { } }; bindService(serviceIntent,serviceConnection,BIND_AUTO_CREATE); isBindService = true; } public void unbindmService(){ if(isBindService == true){ unbindService(serviceConnection); } isBindService = false; } //根据Service内的Livedata来更新数据显示到界面 public void setObserver(){ myService.getMutableLiveData().observe(this, new Observer&lt;String&gt;() { @Override public void onChanged(String s) { showLog.setText(s); } }); }}","link":"/2020/04/25/25/"},{"title":"24","text":"title: Android：使用矢量图图标库+9-patch图进行UI设计tags: [android]categories: android 更加丰富的UI设计，矢量图和 9点图的使用 矢量图UI + 9-Patch适配github：https://github.com/Gong-Shijie/icon-9-Patch 首先矢量图网站：https://www.iconfont.cn/里面提供了丰富的矢量图标，供开发者使用效果： 下载图标 + 导入到Android Studio 9-Patch9-patch图是可以根据内容来自动适配的图片资源可以根据设置的内容来伸缩利用这一特性可以设计出自适应屏幕时出现的拉伸不适于拉伸部分导致的变形问题比如我们的message发送的气泡始终会根据信息长度自动的伸缩 左边和上边框用来标记需要被拉伸的区域右边和下边的边框用来标记内置的内容对齐的区域使用9-Patch来作为View或者Layout的background可以用来适配不同尺寸的屏幕 主要代码XML 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/l1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;100dp&quot;&gt; &lt;ImageView android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:layout_marginLeft=&quot;20dp&quot; android:src=&quot;@drawable/ic_course&quot; android:layout_gravity=&quot;top|left&quot; &gt;&lt;/ImageView&gt; &lt;ImageView android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:layout_marginLeft=&quot;40dp&quot; android:src=&quot;@drawable/ic_back&quot;&gt;&lt;/ImageView&gt; &lt;ImageView android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:layout_marginLeft=&quot;50dp&quot; android:src=&quot;@drawable/ic_0&quot;&gt;&lt;/ImageView&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id=&quot;@+id/l2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/l1&quot; android:layout_marginTop=&quot;30dp&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ImageView android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:src=&quot;@drawable/ic_1&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_gravity=&quot;left&quot; &gt;&lt;/ImageView&gt; &lt;ImageView android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:layout_marginLeft=&quot;40dp&quot; android:src=&quot;@drawable/ic_2&quot;&gt;&lt;/ImageView&gt; &lt;ImageView android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:layout_marginLeft=&quot;50dp&quot; android:src=&quot;@drawable/ic_3&quot;&gt;&lt;/ImageView&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_below=&quot;@id/l2&quot; android:layout_width=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:layout_marginTop=&quot;100dp&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:id=&quot;@+id/t1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@drawable/message_left&quot; android:text=&quot;hello world!&quot;&gt; &lt;/TextView&gt; &lt;TextView android:id=&quot;@+id/t2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@drawable/message_left&quot; android:text=&quot;这是一条长文本，测试伸缩效果。&quot;&gt; &lt;/TextView&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt;","link":"/2020/04/25/24/"},{"title":"3","text":"title: androidApi: AsyncTasktags: [android]categories: android 轻量级多线程方案 多线程方式基石：HandlerHandler是一种线程发消息的机制，Looper被线程持有，保存在ThreadLocal中，一个线程一个Looper（需要时候创建），在A线程创建Handler，Handler就会使用A线程拥有的Looper（创建MessageQueue和从MessageQueue中loop循环取消息）。总结创建handler需要Looper，什么线程创建Handler就会拿什么线程的Looper，也可以直接指定Looper。一个线程的Looper可以用来创建多个Handler，可以被共用，但是MessageQueue中取消息总是可以根据消息的target送到指定的Handler中来处理。很多场景会共用Looper，比如这里的AsyncTask就共用了main UI线程的Looper，使得onPostExecute和onProgressUpdate可以运行在主线程。 AsyncTaskThreadPoolExecutorIntentServiceRxJava Kotlin协程 AsyncTask使用方法 继承该抽象类 12345678910111213141516171819202122232425262728293031323334public class CountTask extends AsyncTask&lt;String,Integer,String&gt; { private Context context; public CountTask(Context context) { this.context = context; } @Override protected String doInBackground(String... strings) { Log.i(&quot;gong&quot;,Thread.currentThread().getName()); for (int i = 0; i &lt; 10; i++) { try { Thread.sleep(1000); publishProgress(i); } catch (InterruptedException e) { e.printStackTrace(); } } return null; } @Override protected void onPostExecute(String s) { Toast.makeText(context,&quot;后台计数结束！&quot;,Toast.LENGTH_SHORT).show(); } @Override protected void onProgressUpdate(Integer... values) { Log.i(&quot;gong&quot;,&quot;进度：&quot;+values[0]); }}``` Activity中使用 //并行执行AsyncTask 其内部有两个线程池 一个是串行执行线程池，一个是并行执行线程池 new CountTask(MainActivity.this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, “hello”); new CountTask(MainActivity.this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, “hello”); #### 优点 * 在后台执行操作后可以很轻松操作更新UI. #### 缺点 * 内存泄漏（doInBackground方法结束控制） * Activity销毁后更新UI失效 * 崩溃，AsyncTask中的线程池是静态创建共享的单例，所有的子类都共用。","link":"/2020/04/25/3/"},{"title":"4","text":"title: androidApi:ConstraintLayouttags: [android]categories: android 更加强大的布局——约束布局 Google API： https://developer.android.com/reference/android/support/constraint/ConstraintLayout 常用组件和属性 位置约束 百分比方法设置宽高 宽高比例ratio设置比例 用⚪半径角度放置组件 参照线guideline放置组件 Group设置组内的visibility placeholder放置组件 chain链式约束 bias设置左右偏移百分比 布局的理想模板（百分比）利用bias和长宽percent可以实现百分比布局效果从而适配各种尺寸的屏幕无论屏幕怎么变化百分比不会改变布局的核心问题：位置和尺寸，将控件摆放的位置和控件的大小尺寸确定，理论上可以解决UI设计适配问题 123456789101112131415161718&lt;TextView android:id=&quot;@+id/textView9&quot; android:text=&quot;TextView&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintWidth_percent=&quot;0.5&quot; app:layout_constraintHeight_percent=&quot;0.1&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;0.8&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt; 位置约束123456789101112131415161718layout_constraintLeft_toLeftOf layout_constraintLeft_toRightOf layout_constraintRight_toLeftOf layout_constraintRight_toRightOf layout_constraintTop_toTopOf layout_constraintTop_toBottomOf layout_constraintBottom_toTopOf layout_constraintBottom_toBottomOf layout_constraintBaseline_toBaselineOf layout_constraintStart_toEndOf layout_constraintStart_toStartOf layout_constraintEnd_toStartOf layout_constraintEnd_toEndOf ``` ***** #### 百分比宽高 app:layout_constraintWidth_percent=”0.5”app:layout_constraintHeight_percent=”0.5” 123***** #### ratio宽高比 app:layout_constraintDimensionRatio=”H,16:9”app:layout_constraintDimensionRatio=”W,16:9”app:layout_constraintDimensionRatio=”16:9” 1234567可以指定固定宽的情况下调整高，H,16:9 也可以固定高的情况下调整宽，W,16:9 ***** #### 圆形布局 ![](https://upload-images.jianshu.io/upload_images/19741117-b195f766b28ac356.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) app:layout_constraintCircle=”@+id/buttonA”app:layout_constraintCircleRadius=”100dp”app:layout_constraintCircleAngle=”45” 1234***** #### 参考线 &lt;androidx.constraintlayout.widget.Guideline android:id=”@+id/guidline” android:layout_width=”wrap_content” android:layout_height=”wrap_content” android:orientation=”vertical” app:layout_constraintGuide_begin=”100dp”&gt; &lt;/androidx.constraintlayout.widget.Guideline&gt; 1234567891011121314151617![利用guideLine摆放控件](https://upload-images.jianshu.io/upload_images/19741117-928fbd0762af5dce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ***** #### group形式设置组内控件的visibility ``` &lt;androidx.constraintlayout.widget.Group android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:visibility=&quot;gone&quot; app:constraint_referenced_ids=&quot;textView,textView2&quot; &gt; ``` ***** #### placeholder 预留控件位置占位用 &lt;androidx.constraintlayout.widget.Placeholder android:id=”@+id/placeholder” android:layout_width=”0dp” android:layout_height=”0dp” android:layout_marginBottom=”23dp” android:background=”@color/colorAccent” app:layout_constraintDimensionRatio=”H,16:9” app:layout_constraintHorizontal_bias=”0.5” app:layout_constraintLeft_toLeftOf=”parent” app:layout_constraintRight_toRightOf=”parent” app:layout_constraintTop_toTopOf=”parent” app:layout_constraintWidth_percent=”0.5”&gt; &lt;/androidx.constraintlayout.widget.Placeholder&gt; 1代码中可以动态加载控件到placeholder中 button = findViewById(R.id.placebtn); placeholder = findViewById(R.id.placeholder); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { placeholder.setContentId(R.id.placebtn); } }); 123456789101112131415161718***** #### chain链式约束 控件之间形成相互约束即可创建链 或者直接选中多个控件点击create chain ![创建链](https://upload-images.jianshu.io/upload_images/19741117-2e4ea0df2d2528b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ![Chain 控件相互约束形成链](https://upload-images.jianshu.io/upload_images/19741117-96218b689f493e2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) chain有很多种style设置不同的样式 在chain head也就是第一个控件设置style ![](https://upload-images.jianshu.io/upload_images/19741117-633f573c9518de2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ***** #### bias偏移百分比 需要设置水平方向位置摆放百分比需要指定 左右都要以parant为约束 同理需要指定为垂直方向则要指定竖直方向都为parant约束","link":"/2020/04/25/4/"},{"title":"5","text":"title: UML基础tags: [java]categories: java 类关系分析工具 UML 环境配置 https://dev.mysql.com/downloads/ 下载Mysql支持 +下载workBench GUI界面 参考进行安装Mysql 在my.ini中配置相关参数https://www.runoob.com/mysql/mysql-install.html 安装环境变量方便使用 注意使用cmd登录到mysql服务的时候尽量以管理员权限操作 workBench 基础操作 mysql -u root -p 连接mysql service CREATE DATABASE LOGDATABASE; 创建数据库更多使用https://www.runoob.com/mysql/mysql-tutorial.html 数据库事务","link":"/2020/04/25/5/"},{"title":"7","text":"title: Git命令合集tags: [git]categories: git 常用的git命令的集合，方便查看 git 信息git config –global user.name “用户名”git config –global user.email “邮箱” 也可以不带信息使用它们查看该项配置git log 打印log信息git init 在当前的目录下建立一个仓库 git 操作git status 查看目前工作空间的状态git add . 将所有仓库文件更新到工作空间git add -u 将修改的文件添加到工作空间git commit -m “描述” 提交现在的工作空间内的更改到代码仓库如果没有-m 需要进入linux下的编辑器 退出方法：ESC + ：wqgit push 将本地的代码仓库状态合并到你的git hub远端仓库git push -f 强制push到远端库git pull 将远端的代码仓库变化合并到本地来git clone github仓库地址 实现在本地创建一个git仓库git reset –hard 版本号 实现版本的回退搭配git push -f使用可以将github版本一同回退 Linux命令 文件操作ls 显示目录下的文件ls -al 显示目录下所有的文件包括隐藏文件cd 目录 进入到指定的目录cd .. 回到上级目录mv .git README.md .. 将目录下的 .git文件 和 README.md 文件移动到上一级目录下 ####流程：github建立仓库—–&gt;在本地的工作目录空间下打开 GIt bash—–&gt;执行git clone操作—–&gt;将相关git文件移动到工作空间子目录删除克隆的目录—–&gt;git push实现push到github","link":"/2020/04/25/7/"},{"title":"6","text":"title: Java：多态：抽象类、继承、接口tags: [java]categories: java 面向对象特征 多态作为Java中十分重要的思想多态。 多态就是一个种类有多种特点，表现。比如人，有男人女人。 多态也可以是一个行为有多种表现。比如同一个方法名，可能有不同实现。 通过Idol作为接口（父类、抽象类），创建了不同的对象，他们都作为一个Idol，却有不同的方法表现和特征。这就是多态。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//java多态实现方法//**********************************1.通过接口创建对象实现多态********************************************************************************************************************************************************************* //直接通过实现接口方法创建对象 Idol vocal = new Idol() { @Override public void sing() { Log.i(tag, &quot;I am a idol, I can sing well!&quot;); } @Override public void dance() { } @Override public void rap() { } @Override public void performance() { sing(); dance(); rap(); } }; vocal.performance(); //通过类来实现接口再来创建对象 Idol dancer = new Dancer(); dancer.performance(); //通过内部类来实现接口来创建对象 class Rapper implements Idol { @Override public void sing() { } @Override public void dance() { } @Override public void rap() { Log.i(&quot;testJava&quot;, &quot;I am a idol, I can rap well!&quot;); } @Override public void performance() { sing(); dance(); rap(); } } Idol rapper = new Rapper(); rapper.performance();//**********************************2.通过子父类继承创建对象实现多态*********************************************************************************************************************************************************************\\ Idol vocal2=new Vocal(); vocal2.performance();//**********************************3.通过抽象类来创建对象实现多态*********************************************************************************************************************************************************************\\ Idol vocal3 = new IdolAbs() { @Override public void sing() { Log.i(tag, &quot;I am a idol, I can sing well!&quot;); } }; vocal3.performance();","link":"/2020/04/25/6/"},{"title":"8","text":"title: 计算机网络：局域网LANtags: [计算机网络]categories: 计算机网络 局域网 #ARP协议ARP协议完成IP地址到MAC地址的映射，根据IP地址查找到MAC地址的过程。数据链路层需要完成局域网内的传递需要使用ARP协议，因为在局域网内的传递需要MAC地址作为导向主机A想发送数据报给主机B，分析它的IP发现位于一个子网内，选择直接发送的方法，于是开始查找ARP表发现没有记录，广播查询局域网都可达包括交换机，B主机单播返回自己的MAC地址如果主机A想要跨局域网传送数据报给主机B，那么主机A在知道B的IP的条件下怎么访问到主机B呢，路由是如何进行的呢因为主机A通过对B的IP知道它们不属于一个局域网，那么就会将来自A的数据报封装目的MAC是R默认路由器交给它来路由。#以太网的结构注意这里的冲突域的概念，冲突域意味着发发送数据的时候需要共享链路就会发生碰撞。需要使用CSMA/CD协议来协调冲突域影响着吞吐量，如果是集线器是不会改变冲突域，不会改变吞吐量，如果是交换机就会扩充冲突域增大了吞吐量#虚拟局域网VLAN#无线局域网#PPP协议#交换机switch、路由器router、集线器Hub##交换机 ##单播、广播、多播#CSMA/CD这里的CSMA/CD每一个帧传输建议从bit的微观角度分析，因为每一个帧是很长的每一个bit需要传输和传播","link":"/2020/04/25/8/"},{"title":"9","text":"title: 计算机网络：传输层tags: [计算机网络]categories: 计算机网络 计算机网络传输层介绍 #1.传输层的服务和协议上下文：上层应用层，下层网络层。传输层的作用是实现进程间的逻辑通信。收到来自应用层的消息将它拆分为一个个segment向下通过socket传递给网络层，收到网络层提取的segment还原为组装为消息通过socket上交给应用层。 socket编程即是封装了两种传输层的协议UDP+TCP（也可以自定义写其他协议）给上层应用层。很多时候应用层编程会使用UrlConnection比直接使用Socket要简单的多，不用关心状态和线程治理。 UrlConnection基于Http协议，只是进行了封装，添加了一些额外规则（如头信息），本质上也是建立TCP连接，利用Socket实现连接和传输数据的。 #2.传输层技术层面##2.1 多路复用分用)比起无连接的分用有连接的分用有四个标识的字段，可以更加精准的建立连接导向到指定的socket，无连接只可以通过端口号来导向（意味着端口号必须不同），有连接的分用则可以使用相同的端口号，因为还有其他字段的存在。##2.2 可靠数据传输a图介绍了可靠数据传输的角色是在应用层之下提供一个可靠数据传输，b图说明可靠数据传输通过对传输层前后的数据做处理进而为上层服务。)Rdt 1.0就是最原始的模型，可靠数据传输通过实现对data的make_pkt()方法使得传输的data不错不丢。这个FSM（状态机）比较好的阐述了可靠数据传输实现的机制。因为前面rdt1.0假设不会发生位错误，都是实际会在传输过程发生位错误。增加校验和如果错误就发送NAK让发送方重新发送。诞生了rdt2.0 停等协议 一直在停和等待的状态)))))也就相当于对接收方不发送NAK，收到重复的ack就相当于nak。发送带有序号的ack，发送方如果不是想要的ack0就继续重新发送数据包0，如果收到ack0就发送数据包1。rdt3.0针对分组如果丢失分组产生无限等待的问题增加计时器，超时重传。))rdt3.0虽然可以正确的工作，但是由于还是停等协议，所以浪费了资源带宽。起码rdt3.0完成了它的任务可靠数据传输。rdt3.0效率低分析：由于只发送一个分组就陷入等待接收确认，这样一个分组发送等待确认再发送的机制（只需要一个bit的序列号就可以满足不接受重复的分组）效率低。##2.3 滑动窗口协议)))))))发送方和接收方的窗口大小之和应该小于序列号总数 ##2.4 拥塞避免)))如果网络拥塞情况严重，路由器或者交换机将data里特定的标记网络拥塞情况的bit置1，接收方将该信息返回给发送方从而控制发送速率实现拥塞控制。##2.5 流量控制设置buffer来通过在返回的segment里面增加返回接收窗口大小来实现。具体研究TCP的流量控制实现。 #3. UDP 尽力而为只完成传输层的基本任务，实现进程之间的通信。segment结构如下：数据保存的就是封装的应用层的message数据。UDP应用于DNS)#4. TCP 可靠服务##4.1 TCP可靠数据传输))))关于GBN和SR与TCPTCP的实现运用了之前介绍的RDT系列算法里面的一些机制，也借鉴了滑动窗口协议的机制。比如TCP采用了累积确认，和SR类似有缓冲区，但是ack的含义不同于SR，ack为期待接受的下一个数据报文的序号，它有快速重传机制，可以提高效率，发送多个ack，发送方收到重复的ack（意味着可能发生了超时或丢包）时候就会重传。 ##4.2 TCP流量控制)流控是针对接收方的接收速度和拥塞控制不同，拥塞控制是数据在网络传输过程，也就是在路由器的缓存有限防止路由器丢包和崩溃导致数据丢失和传输过慢。##4.3 TCP连接管理)第三次可能就携带数据比如html请求之类的信息，注意SYN的变化110)##4.4 TCP的拥塞控制)上图和教材版本不同仅作为参考发生timeout时候congwin减少为1开始慢启动，threshold折半收到三个ack时候congwin折半+3，threshold折半启动拥塞避免开始线性增长 控制机制：监控segment接受的状态（超时和3个ack）—-&gt;启动拥塞控制协议—-&gt;慢启动和拥塞避免—–&gt;congwin的值发生改变—-&gt;发送方根据rate = congwin/RTT的速率发送其实是通过congwin（一个描述当前拥塞程度的量）来控制发送速率 ##4.5 TCP探讨TCP在发送很多的数据时出现丢包率严重，未来的TCP需要重新改进设计。TCP和UDP的公平性问题。对于采用UDP的端就不受拥塞控制限制速率 不公平。对于请求打开多个TCP连接请求获得更多的速率 不公平。#5 报文格式汇总))))","link":"/2020/04/25/9/"}],"tags":[],"categories":[]}